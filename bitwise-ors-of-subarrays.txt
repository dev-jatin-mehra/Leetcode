Q.898
Given an integer array arr, return the number of distinct bitwise ORs of all the non-empty subarrays of arr.

The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer.

A subarray is a contiguous non-empty sequence of elements within an array.

Example 1:

Input: arr = [0]
Output: 1
Explanation: There is only one possible result: 0.
Example 2:

Input: arr = [1,1,2]
Output: 3
Explanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].
These yield the results 1, 1, 2, 1, 3, 3.
There are 3 unique values, so the answer is 3.
Example 3:

Input: arr = [1,2,4]
Output: 6
Explanation: The possible results are 1, 2, 3, 4, 6, and 7.

Constraints:

1 <= arr.length <= 5 * 104
0 <= arr[i] <= 109

Brute :
class Solution
{
public:
    int subarrayBitwiseORs(vector<int> &arr)
    {
        vector<vector<int>> store;
        for (int i = 0; i < arr.size(); i++)
        {
            for (int j = i; j < arr.size(); j++)
            {
                vector<int> sub_store;
                for (int k = i; k <= j; k++)
                {
                    sub_store.push_back(arr[k]);
                }
                store.push_back(sub_store);
            }
        }

        vector<int> or_store;

        for (int i = 0; i < store.size(); i++)
        {
            int bit_or = 0;
            for (int j = 0; j < store[i].size(); j++)
            {
                bit_or |= store[i][j];
            }
            or_store.push_back(bit_or);
        }

        unordered_map<int, int> unique;
        for (auto it : or_store)
        {
            unique[it]++;
        }

        return unique.size();
    }
};

Optimal :
class Solution {
public:
    int subarrayBitwiseORs(vector<int>& arr) {
        unordered_set<int>or_store;
        unordered_set<int>prev_or_store;

        for(int it : arr){
            unordered_set<int>curr;
            curr.insert(it);
            for(int x : prev_or_store){ // 1e9 =~ 2e30 => maxm value that prev_or_store can have is 32. hence its size will be max 32 . i.e traversing its elements is O(1) operation.
                curr.insert(x|it);
            }
            prev_or_store=curr;
            or_store.insert(curr.begin(),curr.end());
        }
        return or_store.size();
    }
};

Test Case : 
arr = [1,2,4] = [1],[2],[4],[1,2],[2,4],[1,2,4] {subarrays}

1. curr = {1}           prev_or_store = {1}         or_store = {1}
2. curr = {2,3}         prev_or_store = {2,3}       or_store = {1,2,3}
3. curr = {4,6,7}       prev_or_store = {4,6,7}     or_store = {1,2,3,4,6,7} FinalAns