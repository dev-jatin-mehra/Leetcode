Q.918
Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.

A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].

A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.

Example 1:

Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3.
Example 2:

Input: nums = [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.
Example 3:

Input: nums = [-3,-2,-3]
Output: -2
Explanation: Subarray [-2] has maximum sum -2.
 
Constraints:

n == nums.length
1 <= n <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104

Brute : 

class Solution
{
private:
    void rotate(vector<int> &arr)
    {
        int start_num = arr[0];
        for (int i = 1; i < arr.size(); i++)
        {
            arr[i - 1] = arr[i];
        }
        arr[arr.size() - 1] = start_num;
    }

    int kadanes(vector<int> &arr)
    {
        int current_max = arr[0], global_max = arr[0];
        for (int i = 1; i < arr.size(); i++)
        {
            current_max = max(arr[i], current_max + arr[i]);
            global_max = max(global_max, current_max);
        }
        return global_max;
    }

public:
    int maximumCircularSumSubarray(vector<int> &arr)
    {
        int result = -1e4; //-10000
        for (int i = 0; i < arr.size() - 1; i++)
        {
            rotate(arr);
            int sum = kadanes(arr);
            result = max(result, sum);
        }

        return result;
    }
};

Better Version:

class Solution
{
private:
    int kadanes(vector<int> &arr)
    {
        int current_max = arr[0], global_max = arr[0];
        for (int i = 1; i < arr.size(); i++)
        {
            current_max = max(arr[i], current_max + arr[i]);
            global_max = max(global_max, current_max);
        }
        return global_max;
    }

    int kadanes_min(vector<int> &arr)
    {
        int current_min = arr[0], global_min = arr[0];
        for (int i = 1; i < arr.size(); i++)
        {
            current_min = min(arr[i], current_min + arr[i]);
            global_min = min(global_min, current_min);
        }
        return global_min;
    }

public:
    int maximumCircularSumSubarray(vector<int> &arr)
    {
        int Tsum = accumulate(arr.begin(), arr.end(), 0);

        int minSum = kadanes_min(arr); // find the min_Sum, Sub it with total sum get the circular max_Sum, compare with maxSum of actual array
        int maxSum = kadanes(arr);     // Proper kadanes

        return maxSum > 0 ? max(Tsum - minSum, maxSum) : maxSum; // for case -> {-1,-1,-1}
    }
};